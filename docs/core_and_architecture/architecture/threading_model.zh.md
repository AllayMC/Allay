---
comments: true
---

## 线程模型

### 前言

在进行更深入的研究前，了解Allay的线程模型以及背后的设计动机是很有必要的。

这不仅能避免出现非预期的并发问题，还可以在一定程度上提高插件性能

### 世界

不同于Nukkit，在Allay中，每个世界运行在一个独立的线程上

请注意，世界(World)不能简单理解为Nukkit中的世界(Level)。世界由多个维度(Dimension)组成，必须包含一个主世界维度，下届和末地维度是可选的。

不同于Nukkit，每个世界都具有一个**独立的**事件总线（以及任务调度器）。这意味着如果你想监听某个世界中产生的事件，你需要注册监听器到这个世界的事件总线中。

### 服务器实例

服务器实例运行在主线程上。在完成启动任务后，主线程会进入方法Server::start()并在这个方法阻塞直到服务器关闭。

与世界类似，服务器实例同样具有tick(见Server::tick())。tick的速率和世界一致，为每秒20次。在正常情况下，服务器tick的任务十分少以至于可以忽略。
服务器实例同样也具有**独立的**事件总线和任务调度器。与世界无关的事件将会在服务器实例的事件总线上处理（例如玩家进退服）。

### 数据包处理

#### 几个概念

Netty线程：直接调用org.cloudburstmc.protocol.bedrock.packet.BedrockPacketHandler::handlePacket()方法的线程，此线程与底层RakNet有关

网络线程：世界持有的networkThread，是一个虚拟线程

#### 包处理流程

当服务端接受到数据包时，首先会尝试在Netty线程上直接调用PacketProcessor::handleAsync()。此方法有两种返回值：HANDLED和UNHANDLED

若handleAsync()返回了HANDLED，代表这个包已经处理完毕，不会继续进行其他步骤。

若handleAsync()返回了UNHANDLED，代表这个包未处理完毕。接下来，这个数据包将会被添加到世界的同步包队列（packetQueue）中。

**网络线程和其对应世界的世界线程的运行是互斥的**，这意味着在同一时刻只有一个线程在运行，而另一个在休眠。我们使用CAS达到这一目的，若你好奇实现细节，你可以去翻阅源码，这里不做介绍。

网络线程阻塞在一个死循环中，理论上循环的速度远高于20次每秒且不影响性能（因为运行在虚拟线程上）。每次循环网络线程都会去查看同步包列表，若不为空则调用PacketProcessor::handleSync()处理数据包。此方法没有返回值，这是数据包的最终一站。

#### 设计动机

这么设计的最大原因是：我们希望能尽量快地处理一个数据包，这在PVP，小游戏服中具有重要意义。

在Nukkit中，使所有数据包都是在主线程处理的。主线程tick速度是20次每秒，这意味着服务端并不能立即处理收到的数据包，最坏情况下需要等待50ms。

这可以简单理解为玩家延迟变高了，具体体现为放置或破坏方块/攻击玩家或生物具有更明显的滞后感。这在生存玩法服务器中不会引起太大问题，但是在小游戏玩法服务器中会有很大问题。