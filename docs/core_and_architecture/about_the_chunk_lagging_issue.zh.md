卡区块已经是一个很久的问题了，并且我们一直在寻找问题根源和解决方案。以下是对目前进度的一个总结

## 问题概述

玩家在跑图时，概率出现部分区块不加载的情况，具体表现为出问题区块所有方块显示为透明但有碰撞箱，
出问题区块附近的未加载区块有较大概率被影响并表现出相同症状。同时，在卡区块现象发生后，
客户端还有较大概率出现一系列其他问题，包括但不限于不能正常收发部分网络包


## 初步调查

我们进行了仔细的排查，排除了服务端未将区块成功发送的可能性，即此问题大概率是客户端出错。
注意到在BDS中很少出现甚至不出现此问题，我们将注意力转向区块发送时序并控制变量进行了一系列的实验, 结果如下：

- 每gt发送区块包越少越不容易卡区快（此项影响大）
- SYNC模式比ASYNC模式不容易卡区快
- 开启子区块发送系统后小幅度提高卡区快概率
- 视距越大越容易卡区快

最开始我们认为可能是NetworkChunkPublishUpdatePacket(NCP)这个包的错误使用导致了此问题，
我们进行了一系列尝试，包括但不限于调整NCP与LevelChunkPacket(LCP)的发包先后关系，甚至尝试过每gt都发一个NCP（思路来源于df-mc），
遗憾的是，上述尝试均没有获得显著的效果，只是略微降低了这个问题的出现概率

## LCP的锅?

Cool_Loong随后指出，allay的区块包编码有可能存在问题，后面也确实发现了两个问题：

- 群系编码不正确
- 空section处理逻辑不正确

在修复了上述两个问题后，我们欣慰地注意到，卡区块现象第一次有了较明显的改进，甚至一度不再出现。
不过很可惜，时间证明此问题仍然没有彻底解决，我们依然不时注意到此问题，特别是在传送到新世界时，旧世界的部分区块会一直遗留，必须重进解决

## 时序

我们再次分析了此问题的种种现象，并注意到两个关键点：

- 出问题时客户端网络线程会部分或全部阻塞
- 区块包发送速率越小越不容易出问题

我们不禁猜想，此问题是否是因为**客户端在短时间内处理了大量区块包**，导致部分区块包不能被正常解码？考虑到区块包是一个较复杂的数据包，前面的猜想确实有很大可能。
接下来进行的一系列测试更加验证了这个观点。

基于以上猜想，我们尝试对此问题的一系列现象进行了解释：

### 为什么卡区快时网络线程会瘫痪？

正如猜想所说，客户端对部分区块包的解析出现了问题，并在客户端网络线程抛出了异常导致正常逻辑不能运行，最后导致网络线程瘫痪

### 为什么区块发送策略SYNC比ASYNC更不容易卡区快？

区块同步发送时，时序是基本固定的，故区块发送速率应稳定在一个值上。
然而在异步发送时，有可能出现一瞬间发送了大量区块（或两个区块包几乎同时发送）的情况，
导致瞬时区块发送速率非常大，这满足了猜想中卡区块的触发条件

### 为什么开启子区块发送系统后小幅度提高卡区快概率？

子区块发送系统会发送大量子区块包（大量发包）

## 初步结论

错误的区块包以及过快的区块包发送速率都会导致卡区快现象的出现，
基于以上认识，在区块包编码无误的前提下，限制区块包的发送速率是行之有效的方法。
通过调低`world-settings.chunk-try-send-count-per-tick`的值，
我们发现卡区块现象几乎消失



