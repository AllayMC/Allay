package org.allaymc.api.server;

import eu.okaeri.configs.ConfigManager;
import org.allaymc.api.ApiInstanceHolder;
import org.allaymc.api.command.CommandSender;
import org.allaymc.api.eventbus.EventBus;
import org.allaymc.api.i18n.MayContainTrKey;
import org.allaymc.api.i18n.TrContainer;
import org.allaymc.api.player.manager.PlayerManager;
import org.allaymc.api.plugin.PluginManager;
import org.allaymc.api.scheduler.Scheduler;
import org.allaymc.api.scheduler.TaskCreator;
import org.allaymc.api.scoreboard.ScoreboardManager;
import org.allaymc.api.utils.Utils;
import org.allaymc.api.world.World;
import org.allaymc.api.world.WorldPool;

import java.nio.file.Path;
import java.util.concurrent.ExecutorService;

/**
 * @author daoge_cmd
 */
public interface Server extends TaskCreator, CommandSender {

    ApiInstanceHolder<Server> INSTANCE = ApiInstanceHolder.create();

    String SETTINGS_FILE_NAME = "server-settings.yml";

    ServerSettings SETTINGS = ConfigManager.create(ServerSettings.class, Utils.createConfigInitializer(Path.of(SETTINGS_FILE_NAME)));

    /**
     * Retrieves the server instance.
     *
     * @return the current server instance
     */
    static Server getInstance() {
        return INSTANCE.get();
    }

    /**
     * Retrieves the server's start time.
     *
     * <p>The returned value corresponds to the system time at which the server started,
     * obtained using {@link System#currentTimeMillis()}.</p>
     *
     * @return the server start time in milliseconds
     */
    long getStartTime();

    /**
     * Retrieves the server's scheduler.
     *
     * <p>For world-related operations, use the scheduler of the respective world instead,
     * as this scheduler runs on the server thread and may encounter concurrency issues
     * when modifying worlds.</p>
     *
     * @return the server scheduler
     * @see World#getScheduler()
     */
    Scheduler getScheduler();

    /**
     * Retrieves the plugin manager responsible for handling plugins.
     *
     * @return the plugin manager instance
     */
    PluginManager getPluginManager();

    /**
     * Retrieves the current server tick.
     *
     * @return the current tick count
     */
    long getTick();

    /**
     * Shutdown the server.
     */
    void shutdown();

    /**
     * Retrieves the current state of the server.
     *
     * @return the server state
     */
    ServerState getState();

    /**
     * Retrieves the world pool.
     *
     * @return the world pool instance
     */
    WorldPool getWorldPool();

    /**
     * Retrieves the compute thread pool.
     *
     * @return the compute thread pool
     */
    ExecutorService getComputeThreadPool();

    /**
     * Retrieves the virtual thread pool.
     *
     * @return the virtual thread pool
     */
    ExecutorService getVirtualThreadPool();

    /**
     * Retrieves the player manager for managing players on the server.
     *
     * @return the player manager
     */
    PlayerManager getPlayerManager();

    /**
     * Broadcasts a text message to all players and the server console.
     *
     * @param text the text message to broadcast
     */
    default void broadcastText(String text) {
        getPlayerManager().getPlayers().values().forEach(player -> player.sendText(text));
        sendText(text);
    }

    /**
     * Broadcasts a translatable text message.
     *
     * @param tr the translation key of the message
     */
    default void broadcastTr(@MayContainTrKey String tr) {
        broadcastTr(tr, new Object[0]);
    }

    /**
     * Broadcasts a translatable text message with arguments.
     *
     * @param tr   the translation key of the message
     * @param args the arguments for the translatable text
     */
    void broadcastTr(@MayContainTrKey String tr, Object... args);

    /**
     * Broadcasts command execution outputs to all players.
     *
     * @param sender  the command sender
     * @param status  the return value of the executed command
     * @param outputs the outputs generated by the command execution
     */
    default void broadcastCommandOutputs(CommandSender sender, int status, TrContainer... outputs) {
        sendCommandOutputs(sender, status, outputs);
        getPlayerManager().getPlayers().values().forEach(player -> player.sendCommandOutputs(sender, status, outputs));
    }

    /**
     * Retrieves the event bus.
     *
     * @return the event bus instance
     */
    EventBus getEventBus();

    /**
     * Retrieves the scoreboard manager.
     *
     * @return the scoreboard manager instance
     */
    ScoreboardManager getScoreboardManager();
}
